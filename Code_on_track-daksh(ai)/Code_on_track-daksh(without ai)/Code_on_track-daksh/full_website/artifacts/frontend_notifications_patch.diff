--- a/frontend/src/api/notifications.ts
+++ b/frontend/src/api/notifications.ts
@@ -19,15 +19,26 @@ export interface Notification {
     id: number;
     type: string;
     title: string;
     message: string;
     severity: 'info' | 'warning' | 'danger' | 'success';
     is_read: boolean;
     created_at: string;
     metadata?: NotificationMetadata;
 }
 
+// Response wrapper from backend
+interface NotificationsResponse {
+    unread_count: number;
+    notifications: Array<{
+        id: number;
+        type: string;
+        title: string;
+        message: string;
+        severity: string;
+        read: boolean;  // Backend uses 'read', frontend uses 'is_read'
+        created_at: string;
+        metadata?: NotificationMetadata;
+    }>;
+}
+
 export const getNotifications = async (): Promise<Notification[]> => {
-    const response = await axios.get<Notification[]>('/notifications');
-    return Array.isArray(response.data) ? response.data : [];
+    const response = await axios.get<NotificationsResponse>('/notifications');
+    // Handle both array and wrapper object responses
+    const data = response.data;
+    
+    let notifications: any[];
+    if (Array.isArray(data)) {
+        notifications = data;
+    } else if (data && Array.isArray(data.notifications)) {
+        notifications = data.notifications;
+    } else {
+        return [];
+    }
+    
+    // Map 'read' to 'is_read' for frontend compatibility
+    return notifications.map(n => ({
+        ...n,
+        is_read: n.is_read ?? n.read ?? false,
+        severity: n.severity || 'info'
+    }));
 };
 
 export const getUnreadCount = async (): Promise<number> => {
     try {
-        const response = await axios.get<Notification[]>('/notifications?unread_only=true');
-        const data = Array.isArray(response.data) ? response.data : [];
-        return data.length;
+        const response = await axios.get<NotificationsResponse>('/notifications?unread=true');
+        const data = response.data;
+        // Backend now returns unread_count directly
+        if (typeof data === 'object' && 'unread_count' in data) {
+            return data.unread_count;
+        }
+        // Fallback: count manually
+        const notifications = Array.isArray(data) ? data : (data?.notifications || []);
+        return notifications.filter((n: any) => !n.read && !n.is_read).length;
     } catch (error) {
         return 0;
     }
 };

-export const markNotificationsRead = async (id: number): Promise<void> => {
-    await axios.patch(`/notifications/${id}/read`);
+export const markNotificationsRead = async (id: number | number[]): Promise<void> => {
+    const ids = Array.isArray(id) ? id : [id];
+    await axios.post('/notifications/mark_read', { ids });
 };
